---
title: "프로그래밍 조언"
excerpt: "Cs"

categories:
   - csmindset
tags:
   - csmindset

toc: true
toc_sticky: true
   
last_modified_at: 2021-08-14
---

# 어드바이스


* 비전공자라는 이유로 멸시를 받을 수도 있고 받지 않을 수도 있다. Opinion( 멸시를 받지 않을 거라고 생각한다면
멸시 받았을 때 괴롭다 만약 멸시를 받지 않는다면 본전이다. 하지만 멸시받는 것을 당연시 한다면 멸시를 받는다고 해도
크게 괴롭지 않다. 멸시를 안 받는다면 이는 꿈만 같은 일이다. 멸시 받는 것을 당연시 여긴다면 괴롭지 않다.)
</br>  
* 코드를 써보는 경험이 중요하다. 코드를 빠르고 허술하게 작성한 뒤 화면을 보며 생각을 정리하는 것도 한가지 방법론이다.
</br>
* 영타를 빠르게 치는 것이 꽤나 중요하다.
</br>

* 공부가 아니라 가지고 논다고 생각하는 것이 중요하다.
</br>
* 코딩은 복잡해 보이지만 조건문과, 반복문을 이해한다면 사실 매우 쉬운 작업이다.
</br>
* 검색은 영어로 해보는 것이 도움이 된다.
</br>
* 실력으로 증명해야 한다.
</br>
* 나를 Hype up하려는 시도는 좋지 않다.
</br>
* 과도하게 나를 깎아 내리는 것 또한 좋지 않다.
</br>
* 경험을 통해 Authentic한 지식을 얻는 것이 중요하다.
</br>
* 젊을 떄는 좀 굴러도 된다.



# 좋은 코드

## 좋은코드란?
* 읽기 쉽게 작성된 코드 
* 중복이 없는 코드 
* 재사용이 용이한 코드
</br>

## 쓰이지 않는 코드 
쓰지는 않지만 불안해서 삭제하지 못하는 코드는 깨진 유리창 중 하나가 된다.
> 이 불안감은 어디서 오는 것인가?

1. 거리 
코드가 동작하는 곳과 코드가 정의 된 곳간의 물리적 거리가 멀면 파악하기 힘들어진다. 

2. 순수하지 않은 함수 
함수 외부의 어떤 값을 기반으로 동작하는 함수는 그 Side effect를 제어하기 어렵다. 

3. 응급처치를 한 코드
중복으로 빼뒀지만 사용하는 곳에서 다른 로직을 추가해줘야 할때 Side effect가 두려워 함수에 입력을 추가하던가 옵션 값을 추가하여 내부서 억지로 처리할 떄 그 코드는 좋지 않은 코드가 될 확률이 높다.

> 응급처치는 은행대출과도 같다 당장의 문제를 해결하는데 이 보다 좋은 해결책은 없다. 하지만 이는 언젠가는 반드시 갚아야만 하는 빚과 같다.


# 2.좋지 않은 코드를 줄이기 위해서는 무엇을 해야만 하는가?

## 추상화 
추출(extraction) : 특별한 기준 없이 끌어내는 것

추상화(abstraction) : 어떤 대상의 중요한 요점들을 재해석하여 정리한 것이라고 해석할 수 있다.

## 의존성을 드러내기 위한 추상화
함수를 분리할 떄는 그 함수의 역할을 인지하고 하나의 역할만 하도록 정의해야 한다.

즉 의존성을 드러내기 위함이 추출의 목적이 되야 한다.

## 일관성 있는 코드 
일관성은 합의된 convention에 의해 형성된다. Ground rule이 중요한 이유이다.

1. 일관성 있는 Naming
2. 애플리케이션 전반에서 공통으로 사용되는 것들만 Top Level의 디렉토리에서 관리하고 나머지는 각각의 디렉토리에서 관리하는 것.

# 3. 확장성 있는 코드를 짜라

# 데이터 타입

1. Array : 가장 기본적인 자료구조 인덱스 값으로 해당 원소에 접근 가능 논리적 저장 순서와 물리적 저장 순서가 일치한다. 삭제 삽입 과정에서 해당 원소에 접근하여 작업완료 뒤 ((O1)), 또 한가지 작업을 추가로 해줘야 하기 때문에 시간이 더걸린다. 또 삽입과 삭제에 메모리 비용이 추가 발생한다.

2. LInked List : Array의 메모리 비용의 단점을 해결하기 위한 자료구조 하지만 이 자료형만의 단점이 한가지 있는데 위치Search과정에서 첫번째 원소부터 다 확인해봐야 한다는 것이다. 


3. Stack : 선형 자료구조 나중에 들어간 원소가 먼저 나온다. 먼저 들어간 것은 아래로 나중에 들어간 것이 위로 쌓이는 구조이다.

4. Queue : 선형 자료구조의 일종으로 "First in First out"이 특징이다. 즉 먼저 들어간게 먼저 나온다. 


3. Hash Table : hash는 내부적으로 배열을 사용하며 데이터를 저장 하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 찾기위해 인덱스로 접근하게 되는데 인덱스로 저장되는 key의 값이 불규칙 하다는 문제가 있다. 그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유의 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다.

- Hash fucntion : '특별한 알고리즘' 이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해 보인다. 위에서 언급한 '특별한 알고리즘'을 "hash method" 또는 "hash function" 이라고 한다.
하지만 어설픈 method는 collision(서로 다른 두 개의 키가 같은 인덱스로 계산됨을 의미)을 만들어 낼 수도 있다.

## 두가지 방법으로 이러한 충돌을 막을 수 있다.
- Open Address : 해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식

- separate chaining : 연결 리스트나 Tree를 사용하여 저장하는 방식
데이터가 적다면 open address방식 아니라면 separate chaining


# 그외에 Tree, Graph, Binary는 나중에 시간이 있을 때 알아보자.